/*
Разработайте программу, которая получает на вход, в стандартный ввод, путь к файлу.
На выходе программа должна определить, является ли данный файл PNG-изображением.
Данная процедура не просто должна смотреть на расширение файла, но и произвести минимальный анализ его внутренностей, в бинарном режиме.

Внутренности валидного бинарного файла начинаются со специального 8-байтового заголовка.
Нас будут интересовать первые четыре байта. Первый байт всегда имеет значение −119 (число со знаком минус),
а следующие — это просто символы ‘P’, ‘N’, ‘G’, расположенные друг за другом. Обратите внимание, что все они в верхнем регистре.

По результатам проверки пути и внутренностей требуется сообщить пользователю о результате проверки в стандартный вывод.

Советы и рекомендации
Чтобы определить расширение файла, используйте функцию substr, которая получает офсет и длину подстроки и возвращает её.

Что оценивается
Для произвольных путей файлов, введённых пользователем, требуется выдавать корректный результат — являются ли они PNG-файлами или нет.
*/

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main()
{
    cout << "Input way to file: ";
    string sWay, sExp;
    cin >> sWay;
    sExp = sWay.substr(sWay.size() - 4, 4);
    //cout << sExp;
    
    if (sExp != ".png" && sExp != ".PNG") 
    {
        cout << "This file is not *.png";
        return 0;
    }
  
    ifstream file(sWay);

    if (file.is_open())
    {
        char temp[5];
        file.read(temp, sizeof(temp));
        if (temp[0] == -119 && temp[1] == 'P' && temp[2] == 'N' && temp[3] == 'G')
        {
            /*
            for (int i = 0; i < 4; i++)
            {
                cout << temp[i] << " ";
            }
            */
            cout << "This file is *.png";
        }
        else
        {
            cout << "This file is not *.png";
        }
    }
    else
    {
        cout << "This file is not *.png";
    }

    file.close();
    
}